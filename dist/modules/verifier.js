"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var _extends=Object.assign||function(target){var i,source;for(i=1;i<arguments.length;i++){source=arguments[i];for(var key in source){if(Object.prototype.hasOwnProperty.call(source,key)){target[key]=source[key]}}}return target};const isUserName=({validator},configs)=>async name=>{if(!name||validator.isEmpty(name)){throw configs.message.emptyName}if(!validator.isLength(name,{min:1,max:25})){throw configs.message.badFormatName}if(!validator.isAlphanumeric(name)){throw configs.message.badFormatName}return name};const isUserPassword=({validator},configs)=>async password=>{if(!password||validator.isEmpty(password)){throw configs.message.emptyPassword}if(!validator.isLength(password,{min:3,max:20})){throw configs.message.badFormatPassword}return password};const isUserEmail=({validator},configs)=>async email=>{if(!email||validator.isEmpty(email)){throw configs.message.emptyEmail}if(!validator.isEmail(email)){throw configs.message.badFormatEmail}return email};const isUserPseudo=({validator},configs)=>async pseudo=>{if(!pseudo||validator.isEmpty(pseudo)){throw configs.message.emptyPseudo}if(!validator.isLength(pseudo,{min:1,max:25})){throw configs.message.badFormatPseudo}if(!validator.isAlphanumeric(pseudo)){throw configs.message.badFormatPseudo}return pseudo};exports.default=(deps,configs)=>async inputs=>{const pendingValues=Object.keys(inputs).map(key=>{switch(key){case"name":{return isUserName(deps,configs)(inputs[key])}case"password":{return isUserPassword(deps,configs)(inputs[key])}case"email":{return isUserEmail(deps,configs)(inputs[key])}case"pseudo":{return isUserPseudo(deps,configs)(inputs[key])}default:{return Promise.resolve(inputs[key])}}});const values=await Promise.all(pendingValues);return Object.keys(inputs).reduce((acc,key,i)=>_extends({},acc,{[key]:values[i]}),{})};