"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var _extends=Object.assign||function(target){var i,source;for(i=1;i<arguments.length;i++){source=arguments[i];for(var key in source){if(Object.prototype.hasOwnProperty.call(source,key)){target[key]=source[key]}}}return target};exports.default=({mongo,bcrypt,jwt},configs)=>({getUserData:async id=>{const db=await mongo.MongoClient.connect(configs.database.mongo.uri);const col=await db.collection(configs.database.mongo.collections.users);const user=await col.findOne({_id:mongo.ObjectId(id)},{password:!1});if(!user){throw configs.message.getUserData}db.close();return user},updateUserData:async(id,data)=>{const db=await mongo.MongoClient.connect(configs.database.mongo.uri);const col=await db.collection(configs.database.mongo.collections.users);const user=await col.findOne({_id:mongo.ObjectId(id)},{password:!1});const availableData=await col.findOne({$or:[{pseudo:data.pseudo},{name:data.name},{email:data.email}]},{pseudo:!0,name:!0,email:!0});if(availableData){if(availableData.pseudo===data.pseudo){throw configs.message.alreadyTakenPseudo}if(availableData.name===data.name){throw configs.message.alreadyTakenName}if(availableData.email===data.email){throw configs.message.alreadyTakenEmail}}const newUserData=_extends({},user,data);await col.findOneAndUpdate({_id:mongo.ObjectId(id)},newUserData);db.close();return!0},createUserData:async(id,data)=>{const db=await mongo.MongoClient.connect(configs.database.mongo.uri);const col=await db.collection(configs.database.mongo.collections.users);const databaseUser=await col.findOne({_id:mongo.ObjectId(id)});if(!databaseUser.new){throw configs.message.postData}const availableData=await col.findOne({$or:[{pseudo:data.pseudo},{name:data.name},{email:data.email}]},{pseudo:!0,name:!0,email:!0});if(availableData){if(availableData.pseudo===data.pseudo){throw configs.message.alreadyTakenPseudo}if(availableData.name===data.name){throw configs.message.alreadyTakenName}if(availableData.email===data.email){throw configs.message.alreadyTakenEmail}}const newUserData=_extends({},databaseUser,data,{new:!1});await col.findOneAndUpdate({_id:mongo.ObjectId(id)},newUserData);db.close();return!0},signupUser:async data=>{const db=await mongo.MongoClient.connect(configs.database.mongo.uri);const col=await db.collection(configs.database.mongo.collections.users);const availableData=await col.findOne({$or:[{name:data.name},{email:data.email}]},{name:!0,email:!0});if(availableData){if(availableData.name===data.name){throw configs.message.alreadyTakenName}if(availableData.email===data.email){throw configs.message.alreadyTakenEmail}}const salt=await bcrypt.genSalt(10);const user={new:!0,name:data.name,email:data.email,password:await bcrypt.hash(data.password,salt)};const isSuccess=await col.insertOne(user);db.close();if(!isSuccess){throw configs.message.signupUser}return!0},signinUser:async({name,email,password})=>{const db=await mongo.MongoClient.connect(configs.database.mongo.uri);const col=await db.collection(configs.database.mongo.collections.users);const user=await col.findOne({$or:[{name},{email}]},{password:!0});db.close();if(!user){throw configs.message.signinUser}const isMatch=bcrypt.compareSync(password,user.password);if(!isMatch){throw configs.message.signinUser}const token=jwt.sign({_id:user._id},configs.server.secret,{expiresIn:48*60*60});return token}});